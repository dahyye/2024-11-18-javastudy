package com.sist.main;
/*
 	1차 만든 프로젝트를 오버라이딩해서 2차
 	
 	재사용 오버라이딩- 변경이 가능하다
 		 오버로딩 - 추가가 가능
 		 
 		 
 	class 
 	{
 		--------------------
 		변수 설정 
 		**저장 뎅디터 다른 경우 -> 따로 저장(인스턴스)
 		저장데이터 1개사용 -> 정적
 		=> 데이터 손실이 없어야 하기 때문에 private를 주로 사용
 			-> 변수마다 기능부여(읽기쓰기getter/setter)
 		--------------------
 		변수초기화 여부 : 생성자 => 생략
 		생성자 : 윈도우, 데이터베이스, 서버연결
 		*없는 경우 => 자동으로 생성자 생성(디폴드로)
 		
 			생성자는 여러개 사용이 가능하다 => 오버로딩
 			클래스명이 같아야한다(리턴형이 없다, void도 리턴형이다)
 			다른 클래스에서 사용이 가능하게 만들어야 하기 때문에 일반적으로 public
 		-----------------------
 		기능설정
 		메소드
 		=> 다른 클래스와 통신을 담당하는 부분(public)
 			형식
 			[접근지정어][제어어] 리턴형 메소드명(메개변수)
 			{
 			
 				return 값;
 			}
 			
 			리턴형 ==> 처리한 결과값 : 한개 설정
 					(기본형/배열/클래스)
 			
 			----------------------------
 			여러개 사용이 가능 => 가급적 3개이상이면 
 								배열/클래스
 			
 			=> 호출 
 			인스턴스
 				객체 생성 후 처리
 				객체.메소드(값...)
 			static
 				클래스명.메소드()
 			
 		**인스턴스 메소드, 생성자
 			=> 인스턴스변수, 메소드, static변수, static메소드 사용가능
 		**static메소드,static블록
 			=> static메소드,static변수만 사용이 가능
 			=> 인스턴스 사용시에는 반드시 객체 생성 후 사용
 			=> 제약이 많다
 		
 		[접근지정어]
	 		public : 
	 		default : 
	 		default : 같은 패키지안에서 사용이 가능
	 				  Component 사용시에 주로 사용
	 				  
	 				  *윈도우
	 				  Component : Button,TextField...
	 				  Container : JFrame, JPanel
	 		private : 개인 정보 보호
	 				  일반 멤버변수 : private
	 				  => getter/setter => 캡슐화
	 			
 		제어어
 			static : 공통으로 사용하는  
 			abstract : 추상적인 => 구현이 안된
 					=> 버튼 / 마우스 / 키보드
 					=> 프로그램에 맞게 구현해서 사용
 					=> 인터페이스
 			final : 마지막인
 				변수 => 상수
 				메소드 => 종단 메소드
 				클래스 => 종단 클래스
 				-----------------> 확장이 불가능 ( 상속이 안된다 )

 		
 		
 			
 			
 	}					
 		 
 */
public class 정리_6 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
	}

}
