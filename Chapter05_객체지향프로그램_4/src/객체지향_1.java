/*
 	수업진행순서
 	이번주 메소드 접근지정어 상속 포함 클래스종류(추상클래스, 인터페이스)
 	다음주 예외처리 라이브러리
 	1월 프로젝트 / 오라클 => 시작 크롤링
 	브라우저(HTML/CSS/JavaScript)
 	서버연결 JSP(1차)
 	스프링(2차) => 파이썬(데이터분석), 띰ㄴ샻ㄴㄷㅁㄱ초
 	개인프로젝트 => 최신기술(취업목적
 	AWS => 리눅스 기반 => 운영체제를 빌려서 사용 (1년무료)
 	옵션(MSA => Cloud => CI/CD)
 	
 	
 	114~116page
 	객체 구성
 		= 속성(변수) / 동작(메소드)
 		= 여러개의 독립적인 단위 => 부품 => 조립
 							  ---    ---프로그래밍
 							  프로그램
 
 		객체를 만들 때 사용하는 키워드(설계)
 		--------------------------- 클래스
 		메모리에 저장후 사용
 		--------------- 인스턴스
 		
 		객체지향프로그램의 단점
 			속도가 느리다
 			결합성이 높다 -> 보안하기 위해서 POJO(Plain Old Java Obect)
 										말 그대로 해석하면 오래된 방식의 간단한 자바 오브젝트
 											
 	
 	118page~121page
 		=> 객체에 대한 설계
 		=> 클래스의 구성요소
 			class ClassName
 			{
 				---------------------------------------------------------------------------
 				멤버변수
 					인스턴스변수 -> 객체 생성시마다 메모리가 다른 공간에 저장
 					정적변수(static) -> 메모리 공간을 한개만 만들어서 공유 -> 공유변수
 						싱클턴 : 하나의 객체 생성 => 데이터베이스 연동
 											=> 스트링은 모든 클래스가 싱글턴
 				객체지향에서는 데이터를 보호하는 걸 권장 => 이걸 캡슐화라고해
 													데이터 은닉화 -> 메소드를 통해서 접근하는 방식
 													변수의 역할 : 읽기(getXxx()), 쓰기(setXxx())
 													**lombok활용(어노테이션 기반으로 코드를 자동완성 해주는 라이브러리)
				---------------------------------------------------------------------------
 				생성자 
 					변수에 대한 초기화 담당, 시작과 동시에 처리 기능
 					=> 생락이 가능 => 생성자가 없으면 컴파일과 동시에 자동으로 매개변수가 없는 생성자가 생성된다(디폴트생성자)
 					리턴형이 없고, 클래스명과 동일, 오버라이딩할 땐 매개변수갯수나 타입이 달라야 해
 					초기화시에는 주로 생성자를 이용한다
 					static 변수에 대한 초기화는 static{}을 이용한다
 						=> 초기화 블럭 : static변수만 초기화가 가능
 				---------------------------------------------------------------------------
 				메소드
 					기능설계
 					설정된 변수를 어떻게 사용할 것인지
 					동작하는 코드 작성
 					자바의 단점 => CallBack을 만들 수 없다
 								---------
 								시스템에 의해 자동 호출
 								=> 사용자정의 메소드는
 								=> 스프링에서는 AOP
 								
 					구성요소
 						리턴형 : 사용자 요청을 처리한 결과값(1개만 사용가능)
 						메소드명 : 메소드명이 메모리 주소
 						 		 소문자로 시작
 						매개변수 : 사용자에게 요청한 값 => 여러개 사용이 가능
 								 일반적으로 매개변수가 3개 이상이면 => 배열/클래스 이용
 								 => 매개변수의 갯수를 모르는 경우
									가변 매개변수 => ...으로 표현
												EX. (String s...)
 						[접근지정어][제어어] 리턴형 메소드명(매개변수)
 						{
 							구현부	
 						}
 				---------------------------------------------------------------------------
 			}	
 			
 			
 			this / this() =>
 			this => 클래스 자신의 메모리 주소를 설정
 					멤버변수와 지역변수가 같은 경우 구분하기 위해 사용
 					JVM=>객체 생성될 때 자동으로 주소값을 저장
 					모든 멤버관련 => 메소드, 변수 앞에 반드시 this.
 					최근에는 this. 생략가능 => 안쓴다는게 아니라 컴파일러에 의해서 자동으로 설정됨
 					
 					컴파일러가 자동 처리
 					=> import java.lang.*;
 					=> 모든 클래스는 Object 상속
 						class A extend Objgec
 					=> 메소드안에서 void => return 추가
 					=> 생성자를 사용하지 않으면 디폴트 생성자 추가
 					=> this.을 생략시에 자동 추가
 			this메소드		
 			this() => 자신 클래스의 생성자를 호출시에 주로 사용
 		   		   => 사용빈도는 거의 없다
 				   => 사용위치는 생성자 안에서 다른 생성자를 호출할 때 사용
 				   		생성자에서 첫번째 줄에서 호출 -> 지키지 않으면 문법상 오류 발생
 		
 		122page
 			객체의 생성과 사용
 			
 			객체의 생명주기 
 			   설계    =>   메모리 저장  =>  활용    =>        메모리회수
 			class 작성 => new 생성자()  =>   메소드  =>   null , system.gc
 				   		
 			=> 이 과정을 알아서 처리해주는 것 Spring
 			
 */
class A
{
	int a;
	int b;

}
class B
{
	int a;
	int b;

}

public class 객체지향_1 {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int a=10;
		int b=a;
		B aa=new B();
		aa.a=100;
		aa.b=200;
		
		B bb=aa;
		System.out.println("aa="+aa);
		System.out.println("bb="+bb);//aa, bb같은 주소값
		System.out.println("bb.a="+bb.a);
		System.out.println("bb.b="+bb.b);//주소값이 같기 떄문에 
										//aa값만 바꿔줘도 bb의 값도 변함
		
		bb.a=1000;
		bb.b=1000;
		
		System.out.println("aa.a="+bb.a);
		System.out.println("aa.b="+bb.b);//bb값을 바꿨지만 aa값도 변화
		//=>Call by Reference
		//클래스나 배열에서 적용되는데
		//String은 일반 변수취급
		String aaa="Java";
		String bbb=aaa; //같은 주소값
		
		bbb="Hello";
		System.out.println(aaa);
		System.out.println(bbb);
		
		
		
		
	}

}
